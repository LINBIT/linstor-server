import org.gradle.process.internal.ExecException

// workaround to force gradle to download not just the dependencies for --offline use
// but also the plugins
buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        if (gradle.startParameter.isOffline()) {
            classpath fileTree(dir: "$projectDir/libs/plugins")
        }
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'application'
apply plugin: 'checkstyle'
apply plugin: 'jacoco'

checkstyleTest.enabled = false

configurations {
    compileClasspath {
        resolutionStrategy.activateDependencyLocking()
    }
    runtimeClasspath {
        resolutionStrategy.activateDependencyLocking()
    }
    annotationProcessor {
        resolutionStrategy.activateDependencyLocking()
    }
}

def protobufVersion = '31.1'
def protoc = file("${projectDir}/tools/protoc-" + protobufVersion + '/bin/protoc')
def logbackConfig = "logback.xml"
def jvmOpts = ["-Xms32M"]
def jvmSatelliteOpts = ["-Xms32M", "-Xmx2G", "-XX:+CrashOnOutOfMemoryError"]
def jvmControllerOpts = ["-Xms256M", "-Xmx8G", "-XX:+CrashOnOutOfMemoryError"]
def cronVersion = '9.2.1'
def javaHome = providers.gradleProperty("javaHome")

group 'com.linbit'

subprojects {
    apply plugin: 'java'
    apply plugin: 'checkstyle'

    compileJava {
        options.release = 11
    }

    repositories {
        mavenCentral()
    }

    installDist {
        duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
    }
}

project(':server') {
    apply plugin: 'java-library'
    apply plugin: 'java-library-distribution'

    dependencies {
        api group: 'com.google.inject', name: 'guice', version: '6.0.0' // upgrade to 7.0 would require switch to jakarta namespace
        api group: 'com.google.inject.extensions', name: 'guice-assistedinject', version: '6.0.0'

//      compileOnly group: 'com.google.protobuf', name: 'protobuf-javalite', version: protobufVersion
        api group: 'com.google.protobuf', name: 'protobuf-java', version: '4.' + protobufVersion

        api 'io.sentry:sentry:5.6.1'
        api 'info.picocli:picocli:4.7.7'

        // project-reactor
        api platform('io.projectreactor:reactor-bom:2023.0.18')
        // add dependencies without a version number
        api 'io.projectreactor:reactor-core'

        compileOnly group: 'org.slf4j', name: 'slf4j-api', version: '2.0.17'
        api group: 'ch.qos.logback', name: 'logback-classic', version: '1.4.14'
        api 'org.apache.httpcomponents.client5:httpclient5:5.4.4'
        api 'com.fasterxml.jackson.jr:jackson-jr-objects:2.18.+'
        api 'com.fasterxml.jackson.core:jackson-databind:2.18.+'

        api group: 'org.apache.commons', name: 'commons-dbcp2', version: '2.13.0'
        api group: 'org.apache.commons', name: 'commons-pool2', version: '2.12.1'
        api group: 'com.h2database', name: 'h2', version: '1.4.197'

        // prometheus client
        api group: 'io.prometheus', name: 'simpleclient_common', version: '0.16.0'

        api platform('com.amazonaws:aws-java-sdk-bom:1.12.784') // switching to awssdk 2.x needs some more work
        api 'com.amazonaws:aws-java-sdk-s3'
        api 'com.amazonaws:aws-java-sdk-ebs'
        api 'com.amazonaws:aws-java-sdk-ec2'

        api group: 'com.cronutils', name: 'cron-utils', version: cronVersion

        // toml parsing library
        api group: 'io.hotmoka', name: 'toml4j', version: '0.7.3'

        // this needs to be moved to the controller, once we have refactored
        // our interfaces requiring this to be here
        api group: 'com.ibm.etcd', name: 'etcd-java', version: '0.0.24'
        constraints {
            api('io.netty:netty-transport-native-epoll:4.1.118.Final') {
                because('to have the same version with newer libs')
            }
            api('io.netty:netty-codec:4.1.118.Final') {
                because('to have the same version with newer libs')
            }
            api('io.netty:netty-codec-http:4.1.118.Final') {
                because('to have the same version with newer libs')
            }
            api('io.netty:netty-codec-http2:4.1.118.Final') {
                because('to have the same version with newer libs')
            }
            api('io.netty:netty-handler:4.1.118.Final') {
                because('to have the same version with newer libs')
            }
            runtimeOnly('io.grpc:grpc-netty:1.72.0') {
                because('newer protobuf version')
            }
            api('io.grpc:grpc-protobuf:1.72.0') {
                because('newer protobuf version')
            }
            api('io.grpc:grpc-stub:1.72.0') {
                because('newer protobuf version')
            }
            api('io.grpc:grpc-netty:1.72.0') {
                because('newer protobuf version')
            }
            api('com.google.code.gson:gson:2.11.0') {
                because('newer protobuf version')
            }
        }

        api group: 'io.fabric8', name: 'kubernetes-client', version: '7.3.1'

        api group: 'com.github.spotbugs', name: 'spotbugs-annotations', version: '4.8.4'

        testImplementation(platform('org.junit:junit-bom:5.13.0'))
    }

    sourceSets {
        main {
            java {
                srcDirs = ["src/main/java", "generated-dbdrivers", "generated-src"]
            }
            resources {
                srcDirs = ["src/main/resources", "generated-resources"]
            }
        }
        test {
            java {
                srcDirs = ["src/test/java"]
            }
        }
    }

    /////////////////////////// Version Info ///////////////////////////
    tasks.register('versionInfo') {
        String propsFile = "$projectDir/generated-resources/version-info.properties"
        outputs.file(propsFile)

        if (project.hasProperty('versionOverride')) {
            logger.warn("Overriding version with $versionOverride")
            version = versionOverride
        }

        if (!project.hasProperty('versionOverride')) {
            File gitFolder = file("$projectDir/../.git")
            if (gitFolder.exists()) {
                try {
                    def stdOut = new ByteArrayOutputStream()
                    def stdErr = new ByteArrayOutputStream()
                    project.exec {
                        commandLine 'make', '-C', '..', 'versioninfo'
                        standardOutput = stdOut
                        errorOutput = stdErr
                    }
                } catch (ExecException exc) {
                    throw new RuntimeException("Cannot generate version.", exc)
                }
            }

            Properties props = new Properties()
            try {
                props.load(new FileInputStream(propsFile))
            } catch (Exception exc) {
                throw new RuntimeException("Cannot read version.", exc)
            }
            version = props.get("version")
        }
    }

    /**
     * Generates Java sources from common API definitions. This includes the protobuf compilation.
     *
     * For package builds this task is run in the 'make debrelease' stage, the generated sources are bundled in the package
     * tarball, and it is then skipped when the package is finally built.
     */
    tasks.register('generateProto', Exec) {
        doFirst {
            if (!protoc.exists()) {
                throw new GradleException("'protoc' binary not found; run the task 'getProtoc' to download the binary")
            }
        }

        commandLine 'make', '-C', "${projectDir}/proto", "PROTOC=" + protoc, 'proto'

        inputs.files(fileTree("${projectDir}/proto"))
        outputs.dir(file("${projectDir}/generated-src"))
    }

    tasks.register('generateJava', Exec) {
        commandLine 'make', '-C', '../linstor-common', 'java'

        inputs.files(fileTree("../linstor-common"))
        outputs.files(file("${projectDir}/generated-src/com/linbit/linstor/api/ApiConsts.java"),
                "${projectDir}/generated-src/com/linbit/linstor/api/prop/GeneratedPropertyRules.java"
        )
        dependsOn generateProto
    }

    tasks.register('cleanProto', Exec) {
        commandLine 'make', '-C', "${projectDir}/proto", 'clean-proto'
    }

    tasks.register('cleanCommon', Exec) {
        commandLine 'make', '-C', "../linstor-common", 'cleanjava'
    }

    processResources.dependsOn versionInfo

    compileJava {
        dependsOn generateJava
    }

    clean {
        delete "${projectDir}/generated-resources"
        dependsOn cleanCommon, cleanProto
    }
}

project(':satellite') {
    apply plugin: 'application'

    dependencies {
        implementation project(':server'), project(':jclcrypto')

        testImplementation(platform('org.junit:junit-bom:5.13.0'))
    }

    sourceSets {
        main {
            java {
                srcDirs = ["src/main/java"]
            }
            resources {
                srcDirs = ["src/main/resources"]
            }
        }
        test {
            java {
                srcDirs = ["src/test/java"]
            }
        }
    }

    startScripts.enabled = false
    tasks.register('SatelliteStartup', CreateStartScripts) {
        mainClass = 'com.linbit.linstor.core.Satellite'
        applicationName = "Satellite"
        outputDir = new File(project.buildDir, 'satellite')
        classpath = files('conf') + files('*')
        defaultJvmOpts = jvmSatelliteOpts
        doLast {
            delete windowsScript
            if (javaHome.present) {
                unixScript.text = unixScript.text.replaceFirst("JAVACMD=\"?java\"?", "JAVACMD=${javaHome.get()}/bin/java")
            }
        }
    }

    distributions {
        main {
            contents {
                from(SatelliteStartup) {
                    into("bin")
                }
            }
        }
    }
}

project(':jclcrypto') {
    apply plugin: 'java-library'
    apply plugin: 'java-library-distribution'

    dependencies {
        implementation project(':server')
    }

    sourceSets {
        main {
            java {
                srcDirs = ["src/main/java", "generated-src"]
            }
        }
        test {
            java {
                srcDirs = ["src/test/java"]
            }
        }
    }
}

version = project(':server').version
project(':controller').version = version
project(':satellite').version = version
project(':jclcrypto').version = version

def jerseyVersion = '2.46'

project(':controller') {
    apply plugin: 'application'

    dependencies {
        implementation project(':server'), project(':jclcrypto')
        testImplementation project(':server'), project(':jclcrypto')

        // rest libs (grizzly http(s), jersey(rest))
        implementation 'org.glassfish.grizzly:grizzly-http-server:4.0.2'
        implementation 'org.glassfish.hk2:guice-bridge:2.6.1'
        implementation group: 'org.glassfish.jersey.inject', name: 'jersey-hk2', version: jerseyVersion
        implementation group: 'org.glassfish.jersey.containers', name: 'jersey-container-grizzly2-http', version: jerseyVersion
        implementation group: 'org.glassfish.jersey.containers', name: 'jersey-container-grizzly2-servlet', version: jerseyVersion
        implementation group: 'org.glassfish.jersey.media', name: 'jersey-media-sse', version: jerseyVersion

        // prometheus client library
        implementation group: 'io.prometheus', name: 'simpleclient_hotspot', version: '0.16.0'

        implementation group: 'org.flywaydb', name: 'flyway-core', version: '7.15.0'

        runtimeOnly 'org.mariadb.jdbc:mariadb-java-client:3.1.4'
        runtimeOnly group: 'org.postgresql', name: 'postgresql', version: '42.7.7'
    }

    sourceSets {
        main {
            java {
                srcDirs = ["src/main/java", "generated-src"]
            }
            resources {
                srcDirs = ["src/main/resources", "generated-resources"]
            }
        }
        test {
            java {
                srcDirs = ["src/test/java"]
            }
        }
    }

    startScripts.enabled = false
    tasks.register('ControllerStartup', CreateStartScripts) {
        mainClass = 'com.linbit.linstor.core.Controller'
        applicationName = "Controller"
        outputDir = new File(project.buildDir, 'controller')
        classpath = files('conf') + files('*')
        defaultJvmOpts = jvmControllerOpts
        doLast {
            delete windowsScript
            if (javaHome.present) {
                unixScript.text = unixScript.text.replaceFirst("JAVACMD=\"?java\"?", "JAVACMD=${javaHome.get()}/bin/java")
            }
        }
    }

    tasks.register('LinstorConfigStartup', CreateStartScripts) {
        mainClass = 'com.linbit.linstor.core.LinstorConfigTool'
        applicationName = "linstor-config"
        outputDir = new File(project.buildDir, 'linstorconfig')
        classpath = files('*')
        defaultJvmOpts = jvmOpts
        doLast {
            delete windowsScript
            if (javaHome.present) {
                unixScript.text = unixScript.text.replaceFirst("JAVACMD=\"?java\"?", "JAVACMD=${javaHome.get()}/bin/java")
            }
        }
    }

    tasks.register('LinstorDbToolStartup', CreateStartScripts) {
        mainClass = 'com.linbit.linstor.core.LinstorDatabaseTool'
        applicationName = "linstor-database"
        outputDir = new File(project.buildDir, 'linstordb')
        classpath = files('*')
        defaultJvmOpts = jvmOpts
        doLast {
            delete windowsScript
            if (javaHome.present) {
                unixScript.text = unixScript.text.replaceFirst("JAVACMD=\"?java\"?", "JAVACMD=${javaHome.get()}/bin/java")
            }
        }
    }

    distributions {
        main {
            contents {
                from(ControllerStartup) {
                    into("bin")
                }
                from(LinstorConfigStartup) {
                    into("bin")
                }
                from(LinstorDbToolStartup) {
                    into("bin")
                }
            }
        }
    }
}

sourceSets {
    test {
        java {
            srcDirs = ["src/test/java"]
        }
    }
}

test {
    finalizedBy jacocoTestReport // report is always generated after tests run
}

jacocoTestReport {
    if (project.hasProperty('CoverageReport')) {
        dependsOn = subprojects.test
        additionalSourceDirs.setFrom(files(subprojects.sourceSets.main.allSource.srcDirs))
        sourceDirectories.setFrom(files(subprojects.sourceSets.main.allSource.srcDirs))
        classDirectories.setFrom(files(subprojects.sourceSets.main.output))
        reports {
            html.required = true
            xml.required = true
            csv.required = true
        }
        onlyIf = {
            true
        }
//        doFirst {
//            executionData.setFrom(files(executionData.findAll {
//                it.exists()
//            }))
//        }
        afterEvaluate {
            excludedClassFilesForReport(classDirectories)
        }
    }
}

jacocoTestCoverageVerification {
    if (project.hasProperty('CoverageReport')) {
        afterEvaluate {
            excludedClassFilesForReport(classDirectories)
        }
    }
}

private excludedClassFilesForReport(classDirectories) {
    classDirectories.setFrom(files(classDirectories.files.collect {
        fileTree(dir: it,
                exclude: [
                        'com/linbit/linstor/proto/**'
                ]
        )
    }))
}

repositories {
    mavenCentral()
}

dependencies {
    implementation project(':server'), project(':controller'), project(':satellite'), project(':jclcrypto')
    testImplementation project(':server'), project(':controller'), project(':satellite'), project(':jclcrypto')

    testImplementation group: 'com.google.protobuf', name: 'protobuf-java', version: '4.' + protobufVersion

    def powerMockVersion = '2.0.9'
    testImplementation(platform('org.junit:junit-bom:5.13.0'))
    testImplementation group: 'org.mockito', name: 'mockito-core', version: '2.28.2'
    testImplementation group: 'org.mockito', name: 'mockito-inline', version: '2.28.2'
    // TODO get rid of unsupported powermock
    testImplementation group: 'org.powermock', name: 'powermock-core', version: powerMockVersion
    testImplementation group: 'org.powermock', name: 'powermock-api-mockito2', version: powerMockVersion
    testImplementation group: 'org.powermock', name: 'powermock-module-junit4', version: powerMockVersion

    testCompileOnly group: 'org.slf4j', name: 'slf4j-api', version: '2.0.17'
    testImplementation group: 'org.assertj', name: 'assertj-core', version: '3.27.+'
    testImplementation group: 'pl.pragmatists', name: 'JUnitParams', version: '1.1.1'

    testImplementation group: 'com.cronutils', name: 'cron-utils', version: cronVersion

    testImplementation group: 'com.google.inject.extensions', name: 'guice-testlib', version: '6.0.0'
    testImplementation group: 'io.projectreactor', name: 'reactor-test', version: '3.6.+'
}

/////////////////////////// Start scripts ///////////////////////////
startScripts.enabled = false

distributions {
    main {
        contents {
            from(project(":controller").ControllerStartup) {
                into("bin")
            }
            from(project(":satellite").SatelliteStartup) {
                into("bin")
            }
            from(project(":controller").LinstorConfigStartup) {
                into("bin")
            }
            from(project(":controller").LinstorDbToolStartup) {
                into("bin")
            }
            from("server/" + logbackConfig) {
                into("lib/conf")
            }
        }
    }
}

installDist {
    duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
}

tasks.register('showMeCache') {
    doLast {
        configurations.runtimeClasspath.each { println it }
    }
}

tasks.register('showMeTestCache') {
    doLast {
        configurations.testRuntimeClasspath.each { println it }
    }
}

/////////////////////////// Test commands ///////////////////////////
tasks.register('buildTestCommands', Exec) {
    workingDir 'test-support'

    commandLine 'make'

    //store the output instead of printing to the console:
    standardOutput = new ByteArrayOutputStream()

    //extension method buildTestCommands.output() can be used to obtain the output:
    ext.output = {
        return standardOutput.toString()
    }
}

tasks.register('unzipProtoc', Copy) {
    dependsOn(downloadProtoc)

    def zipFile = file("tools/protoc-" + protobufVersion + '-linux-x86_64.zip')
    def outputDir = file("tools/protoc-" + protobufVersion)

    from zipTree(zipFile)
    into outputDir
    eachFile {
        if (it.relativePath.getFile(destinationDir).exists()) {
            it.exclude()
        }
    }
}

tasks.register('downloadProtoc') {
    outputs.dir "tools"
    def protozip = new File("${projectDir}/tools/protoc-" + protobufVersion + '-linux-x86_64.zip')
    outputs.file protozip

    doLast {
        if (!protozip.exists()) {
            mkdir "tools"
            println "downloading protoc..."
            new URL('https://github.com/google/protobuf/releases/download/v'
                    + protobufVersion + '/protoc-' + protobufVersion + '-linux-x86_64.zip')
                    .withInputStream { i -> protozip.withOutputStream { it << i } }
        }
    }
}

tasks.register('getProtoc') {
    dependsOn downloadProtoc, unzipProtoc
}

tasks.register('cleanTestCommands', Exec) {
    workingDir 'test-support'

    commandLine 'make', 'clean'

    //store the output instead of printing to the console:
    standardOutput = new ByteArrayOutputStream()

    //extension method buildTestCommands.output() can be used to obtain the output:
    ext.output = {
        return standardOutput.toString()
    }
}

compileTestJava {
  dependsOn buildTestCommands
}

clean {
    dependsOn cleanTestCommands
}

// this task is needed for RPM packaging
// it creates a list of dependency jars needed for the server project
tasks.register('showServerRuntimeLibs') {
    doLast {
        project(':server').configurations.getByName('runtimeClasspath').files.each { f ->
            print('/usr/share/linstor-server/lib/' + f.getName().toString() + '\n')
        }
    }
}

tasks.register('downloadDependencies') {
    doLast {
        subprojects.each { prj ->
            ['compileClasspath', 'runtimeClasspath'].each { scope ->
                prj.configurations.getByName(scope).resolve()
            }
        }
    }
}
